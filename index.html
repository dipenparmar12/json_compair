<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="theme-color" content="#08C988" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Online Text Compare" />
    <title>Compare JSON files online</title>
    <meta
      name="Description"
      content="FREE two-way JSON format, diff and merge tool. No Signup required. Nothing to install. All comparisons are 100% private, secure and happens locally right in your web browser"
    />
    <meta
      name="keywords"
      content="Online JSON Compare - Format and find differences between two JSON files"
    />
    <link
      rel="canonical"
      href="https://dipenparmar12.github.io/json_compair/"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
    />
    <link rel="shortcut icon" href="./img/onlinetextcompare.png" />
    <link rel="stylesheet" href="./css/ccsiteV6.css" />
    <link rel="stylesheet" type="text/css" href="./css/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="./css/merge.css" />
    <link rel="stylesheet" type="text/css" href="./css/app.css" />
    <script src="./js/codemirror.js"></script>
    <script src="./js/diff_match_patch.js"></script>
    <script src="./js/merge.js"></script>
    <script src="./js/javascript.js"></script>
  </head>

  <body>
    <article id="ArticlePage" class="contentPage cover">
      <div
        class="intro"
        style="
          max-width: 100%;
          margin: 0;
          padding: 10px 0;
          text-align: center;
          background-color: #f8f9fa;
        "
      >
        <div class="controls">
          <button id="btn-format" class="toggle-button">
            Format &amp; Compare JSON
          </button>
          <!-- Additional controls will be added by JavaScript -->
        </div>
      </div>
    </article>
    <div id="container">
      <div id="view"></div>
      <div id="diff-status">Found 0 differences</div>
    </div>

    <script type="text/javascript">
      // Smart Number Proximity Comparison Manager
      const ProximityManager = {
        settings: {
          enabled: false,
          floatTolerance: 0.001,
          integerTolerance: 1,
          mixedComparison: true
        },

        STORAGE_KEY: 'json_compare_proximity_settings',

        saveSettings: function() {
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.settings));
        },

        loadSettings: function() {
          const stored = localStorage.getItem(this.STORAGE_KEY);
          if (stored) {
            try {
              this.settings = { ...this.settings, ...JSON.parse(stored) };
            } catch (e) {
              console.warn('Failed to load proximity settings');
            }
          }
        },

        isWithinTolerance: function(val1, val2) {
          if (!this.settings.enabled) return val1 === val2;

          // Handle exact matches first
          if (val1 === val2) return true;

          // Convert to numbers if possible
          const num1 = this.parseNumber(val1);
          const num2 = this.parseNumber(val2);

          // If both are numbers, compare with tolerance
          if (num1 !== null && num2 !== null) {
            const isFloat1 = !Number.isInteger(num1);
            const isFloat2 = !Number.isInteger(num2);
            
            if (isFloat1 || isFloat2) {
              // At least one is float, use float tolerance
              return Math.abs(num1 - num2) <= this.settings.floatTolerance;
            } else {
              // Both are integers, use integer tolerance
              return Math.abs(num1 - num2) <= this.settings.integerTolerance;
            }
          }

          // Mixed comparison: string vs number
          if (this.settings.mixedComparison && (num1 !== null || num2 !== null)) {
            const n1 = num1 !== null ? num1 : this.parseNumber(String(val1));
            const n2 = num2 !== null ? num2 : this.parseNumber(String(val2));
            
            if (n1 !== null && n2 !== null) {
              const isFloat = !Number.isInteger(n1) || !Number.isInteger(n2);
              const tolerance = isFloat ? this.settings.floatTolerance : this.settings.integerTolerance;
              return Math.abs(n1 - n2) <= tolerance;
            }
          }

          return false;
        },

        parseNumber: function(value) {
          if (typeof value === 'number') return value;
          if (typeof value !== 'string') return null;
          
          const trimmed = value.trim();
          if (trimmed === '') return null;
          
          const num = Number(trimmed);
          return isNaN(num) ? null : num;
        },

        compareValues: function(val1, val2) {
          return this.isWithinTolerance(val1, val2);
        }
      };

      // URL Parameter Manager for shareable links (enhanced with proximity settings)
      const URLManager = {
        // Compress data using LZ-String-like compression (simple implementation)
        compress: function(str) {
          try {
            // Use built-in compression if available, otherwise base64 encode
            return btoa(encodeURIComponent(str));
          } catch (e) {
            console.warn('Compression failed, using fallback');
            return encodeURIComponent(str);
          }
        },

        decompress: function(str) {
          try {
            return decodeURIComponent(atob(str));
          } catch (e) {
            console.warn('Decompression failed, using fallback');
            return decodeURIComponent(str);
          }
        },

        saveToURL: function(leftContent, rightContent, includeProximitySettings = true) {
          const params = new URLSearchParams();
          
          if (leftContent.trim()) {
            params.set('left', this.compress(leftContent));
          }
          if (rightContent.trim()) {
            params.set('right', this.compress(rightContent));
          }

          // Include proximity settings in URL if enabled
          if (includeProximitySettings && ProximityManager.settings.enabled) {
            params.set('proximityEnabled', '1');
            params.set('floatTolerance', ProximityManager.settings.floatTolerance.toString());
            params.set('integerTolerance', ProximityManager.settings.integerTolerance.toString());
            params.set('mixedComparison', ProximityManager.settings.mixedComparison ? '1' : '0');
          }
          
          const newUrl = window.location.origin + window.location.pathname + 
                        (params.toString() ? '?' + params.toString() : '');
          
          // Update browser URL without page reload
          window.history.replaceState({}, '', newUrl);
          
          return newUrl;
        },

        loadFromURL: function() {
          const params = new URLSearchParams(window.location.search);
          const leftParam = params.get('left');
          const rightParam = params.get('right');
          
          // Load proximity settings from URL
          if (params.get('proximityEnabled') === '1') {
            ProximityManager.settings.enabled = true;
            ProximityManager.settings.floatTolerance = parseFloat(params.get('floatTolerance')) || 0.001;
            ProximityManager.settings.integerTolerance = parseInt(params.get('integerTolerance')) || 1;
            ProximityManager.settings.mixedComparison = params.get('mixedComparison') !== '0';
          }
          
          if (!leftParam && !rightParam) return null;
          
          return {
            left: leftParam ? this.decompress(leftParam) : '',
            right: rightParam ? this.decompress(rightParam) : ''
          };
        },

        generateShareableURL: function(leftContent, rightContent, includeProximitySettings = true) {
          const params = new URLSearchParams();
          
          if (leftContent.trim()) {
            params.set('left', this.compress(leftContent));
          }
          if (rightContent.trim()) {
            params.set('right', this.compress(rightContent));
          }

          // Include proximity settings in shareable URL if enabled
          if (includeProximitySettings && ProximityManager.settings.enabled) {
            params.set('proximityEnabled', '1');
            params.set('floatTolerance', ProximityManager.settings.floatTolerance.toString());
            params.set('integerTolerance', ProximityManager.settings.integerTolerance.toString());
            params.set('mixedComparison', ProximityManager.settings.mixedComparison ? '1' : '0');
          }
          
          return window.location.origin + window.location.pathname + 
                 (params.toString() ? '?' + params.toString() : '');
        }
      };

      // Storage Manager Implementation (enhanced with proximity settings)
      const StorageManager = {
        STORAGE_KEY: "json_compare_data",
        EXPIRY_DAYS: 30,

        saveToStorage: function (leftContent, rightContent, includeProximitySettings = true) {
          const data = {
            left: leftContent,
            right: rightContent,
            timestamp: new Date().getTime(),
          };

          // Include proximity settings if enabled
          if (includeProximitySettings && ProximityManager.settings.enabled) {
            data.proximitySettings = ProximityManager.settings;
          }

          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        },

        loadFromStorage: function () {
          const storedData = localStorage.getItem(this.STORAGE_KEY);
          if (!storedData) return null;

          const data = JSON.parse(storedData);
          const now = new Date().getTime();
          const age = now - data.timestamp;
          const expiryTime = this.EXPIRY_DAYS * 24 * 60 * 60 * 1000;

          if (age > expiryTime) {
            localStorage.removeItem(this.STORAGE_KEY);
            return null;
          }

          // Restore proximity settings if available
          if (data.proximitySettings) {
            ProximityManager.settings = { ...ProximityManager.settings, ...data.proximitySettings };
          }

          return {
            left: data.left,
            right: data.right,
          };
        },
      };

      // Default templates
      const DefaultTemplates = {
        simple: {
          left: JSON.stringify(
            {
              name: "John",
              age: 30,
              city: "New York",
            },
            null,
            3
          ),
          right: JSON.stringify(
            {
              name: "John",
              age: 31,
              city: "Boston",
            },
            null,
            3
          ),
        },
        complex: {
          left: JSON.stringify(
            {
              users: [
                {
                  id: 1,
                  name: "Alice",
                  active: true,
                },
                {
                  id: 2,
                  name: "Bob",
                  active: false,
                },
              ],
              settings: {
                theme: "dark",
                notifications: true,
              },
            },
            null,
            3
          ),
          right: JSON.stringify(
            {
              users: [
                {
                  id: 1,
                  name: "Alice",
                  active: false,
                },
                {
                  id: 3,
                  name: "Charlie",
                  active: true,
                },
              ],
              settings: {
                theme: "light",
                notifications: true,
              },
            },
            null,
            3
          ),
        },
      };

      // Function to sort JSON object keys recursively
      function sortJSONKeys(obj) {
        if (obj === null || typeof obj !== "object") {
          return obj;
        }
        if (Array.isArray(obj)) {
          return sortJSONArray(obj); // Recursively sort arrays
        }
        const sortedObj = {};
        const keys = Object.keys(obj).sort();
        for (const key of keys) {
          sortedObj[key] = sortJSONKeys(obj[key]);
        }
        return sortedObj;
      }

      // Function to sort array items if they are objects or arrays
      function sortJSONArray(arr) {
        if (!Array.isArray(arr)) {
          return arr;
        }
        // If array contains only objects, sort by their stringified value
        if (
          arr.length > 0 &&
          arr.every(
            (item) =>
              typeof item === "object" && item !== null && !Array.isArray(item)
          )
        ) {
          arr = arr.slice().sort((a, b) => {
            // Sort using stable stringified keys
            const aStr = JSON.stringify(sortJSONKeys(a));
            const bStr = JSON.stringify(sortJSONKeys(b));
            if (aStr < bStr) return -1;
            if (aStr > bStr) return 1;
            return 0;
          });
        }
        return arr.map((item) => {
          if (item && typeof item === "object") {
            return sortJSONKeys(item); // Handles both objects and arrays
          }
          return item;
        });
      }

      // Initialize enhanced merge view
      function initializeMergeView(target) {
        // Load content from URL parameters first, then from storage, then use defaults
        const urlContent = URLManager.loadFromURL();
        const savedContent = StorageManager.loadFromStorage();
        const initialContent = urlContent || savedContent || DefaultTemplates.simple;

        // Create merge view with enhanced options
        const mv = CodeMirror.MergeView(target, {
          value: initialContent.left,
          origLeft: null,
          orig: initialContent.right,
          lineNumbers: true,
          mode: "application/json",
          showDifferences: true,
          connect: "align",
          collapseIdentical: false,
          revertButtons: true,
          allowEditingOriginals: true,
          highlightDifferences: true,
          lineWrapping: true,
          styleActiveLine: true,
          chunkClassLocation: ["background", "wrap", "gutter"],
        });

        // Add scroll synchronization with toggle
        let scrollLocked = true;
        const leftEditor = mv.editor();
        const rightEditor = mv.rightOriginal();

        function syncScroll(sourceEditor, targetEditor) {
          if (!scrollLocked) return;
          const info = sourceEditor.getScrollInfo();
          targetEditor.scrollTo(info.left, info.top);
        }

        leftEditor.on("scroll", () => syncScroll(leftEditor, rightEditor));
        rightEditor.on("scroll", () => syncScroll(rightEditor, leftEditor));

        // Add UI controls
        const controls = document.querySelector(".controls");

        // Create Proximity Settings Panel
        const proximityPanel = document.createElement("div");
        proximityPanel.className = "proximity-panel";
        proximityPanel.innerHTML = `
          <div class="proximity-header">
            <button id="proximity-toggle" class="toggle-button" title="Enable Smart Number Proximity Comparison">
              ðŸ”¢ Smart Numbers
            </button>
            <div class="proximity-settings" style="display: none;">
              <div class="proximity-row">
                <label>Float Tolerance:</label>
                <input type="number" id="float-tolerance" step="0.001" min="0" max="1" value="0.001">
                <span class="tolerance-example">e.g., 19.99 â‰ˆ 19.991</span>
              </div>
              <div class="proximity-row">
                <label>Integer Tolerance:</label>
                <input type="number" id="integer-tolerance" step="1" min="0" max="100" value="1">
                <span class="tolerance-example">e.g., 100 â‰ˆ 101</span>
              </div>
              <div class="proximity-row">
                <label>
                  <input type="checkbox" id="mixed-comparison" checked>
                  Mixed string/number comparison
                </label>
              </div>
              <div class="proximity-actions">
                <button id="apply-proximity" class="apply-btn">Apply</button>
                <button id="reset-proximity" class="reset-btn">Reset to Defaults</button>
              </div>
            </div>
          </div>
        `;
        controls.appendChild(proximityPanel);

        // Proximity toggle functionality
        const proximityToggle = document.getElementById('proximity-toggle');
        const proximitySettings = document.querySelector('.proximity-settings');
        const floatToleranceInput = document.getElementById('float-tolerance');
        const integerToleranceInput = document.getElementById('integer-tolerance');
        const mixedComparisonInput = document.getElementById('mixed-comparison');

        // Update input values with current settings
        floatToleranceInput.value = ProximityManager.settings.floatTolerance;
        integerToleranceInput.value = ProximityManager.settings.integerTolerance;
        mixedComparisonInput.checked = ProximityManager.settings.mixedComparison;

        // Update toggle button state
        function updateProximityToggleState() {
          if (ProximityManager.settings.enabled) {
            proximityToggle.classList.add('active');
            proximityToggle.title = 'Smart Number Proximity Comparison: ON';
          } else {
            proximityToggle.classList.remove('active');
            proximityToggle.title = 'Smart Number Proximity Comparison: OFF';
          }
        }

        // Initialize toggle state
        updateProximityToggleState();

        proximityToggle.onclick = () => {
          ProximityManager.settings.enabled = !ProximityManager.settings.enabled;
          updateProximityToggleState();
          
          if (ProximityManager.settings.enabled) {
            proximitySettings.style.display = 'block';
            // Show helpful notification
            showNotification('Smart Number Proximity enabled! Configure tolerances below.', 'info');
          } else {
            proximitySettings.style.display = 'none';
            showNotification('Smart Number Proximity disabled.', 'info');
          }
          
          ProximityManager.saveSettings();
          updateDiffStatus(mv);
        };

        // Apply proximity settings
        document.getElementById('apply-proximity').onclick = () => {
          const floatVal = parseFloat(floatToleranceInput.value);
          const intVal = parseInt(integerToleranceInput.value);
          
          if (isNaN(floatVal) || floatVal < 0) {
            showNotification('Invalid float tolerance value', 'error');
            return;
          }
          
          if (isNaN(intVal) || intVal < 0) {
            showNotification('Invalid integer tolerance value', 'error');
            return;
          }

          ProximityManager.settings.floatTolerance = floatVal;
          ProximityManager.settings.integerTolerance = intVal;
          ProximityManager.settings.mixedComparison = mixedComparisonInput.checked;
          
          ProximityManager.saveSettings();
          updateDiffStatus(mv);
          
          showNotification('Proximity settings applied successfully!', 'success');
        };

        // Reset proximity settings
        document.getElementById('reset-proximity').onclick = () => {
          ProximityManager.settings.floatTolerance = 0.001;
          ProximityManager.settings.integerTolerance = 1;
          ProximityManager.settings.mixedComparison = true;
          
          floatToleranceInput.value = ProximityManager.settings.floatTolerance;
          integerToleranceInput.value = ProximityManager.settings.integerTolerance;
          mixedComparisonInput.checked = ProximityManager.settings.mixedComparison;
          
          ProximityManager.saveSettings();
          updateDiffStatus(mv);
          
          showNotification('Proximity settings reset to defaults', 'info');
        };

        // Notification system for user feedback
        function showNotification(message, type = 'info') {
          // Remove existing notifications
          const existingNotification = document.querySelector('.proximity-notification');
          if (existingNotification) {
            existingNotification.remove();
          }

          const notification = document.createElement('div');
          notification.className = `proximity-notification ${type}`;
          notification.textContent = message;
          
          // Style based on type
          let backgroundColor = '#007cba'; // info
          if (type === 'success') backgroundColor = '#28a745';
          if (type === 'error') backgroundColor = '#dc3545';
          if (type === 'warning') backgroundColor = '#ffc107';
          
          notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: ${backgroundColor};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-size: 14px;
            max-width: 300px;
            animation: slideIn 0.3s ease;
          `;
          
          document.body.appendChild(notification);
          
          // Auto-remove after 3 seconds
          setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, 3000);
        }

        // Close proximity settings when clicking outside
        document.addEventListener('click', (e) => {
          if (!proximityPanel.contains(e.target)) {
            proximitySettings.style.display = 'none';
          }
        });

        // Prevent closing when clicking inside the settings panel
        proximitySettings.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Show proximity settings if enabled on load
        if (ProximityManager.settings.enabled) {
          proximitySettings.style.display = 'block';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          // Ctrl/Cmd + Shift + P: Toggle proximity
          if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'P') {
            e.preventDefault();
            proximityToggle.click();
          }
          
          // Escape: Close proximity settings
          if (e.key === 'Escape') {
            proximitySettings.style.display = 'none';
          }
        });

        // Add scroll lock toggle
        const scrollLockBtn = document.createElement("button");
        scrollLockBtn.className = "toggle-button active";
        scrollLockBtn.textContent = "Scroll Lock";
        scrollLockBtn.onclick = () => {
          scrollLocked = !scrollLocked;
          scrollLockBtn.classList.toggle("active");
        };
        // controls.appendChild(scrollLockBtn);

        // Add Show Only Differences toggle
        const showDiffsBtn = document.createElement("button");
        showDiffsBtn.className = "toggle-button";
        showDiffsBtn.textContent = "Show Only Differences";

        showDiffsBtn.onclick = () => {
          showDiffsBtn.classList.toggle("active");
          const showOnlyDiffs = showDiffsBtn.classList.contains("active");

          const leftPane = leftEditor.getWrapperElement().parentNode;
          const rightPane = rightEditor.getWrapperElement().parentNode;

          leftPane.classList.toggle("show-diffs-only", showOnlyDiffs);
          rightPane.classList.toggle("show-diffs-only", showOnlyDiffs);

          // If showing diffs, ensure chunks are expanded
          if (showOnlyDiffs) {
            // Get all collapsed markers
            const markers = leftEditor.getAllMarks();
            markers.forEach((marker) => {
              if (marker.collapsed) {
                marker.clear();
              }
            });
          }

          // Refresh both editors
          leftEditor.refresh();
          rightEditor.refresh();

          // Adjust viewport to show first diff if exists
          if (showOnlyDiffs) {
            const chunks = mv.rightChunks();
            if (chunks && chunks.length > 0) {
              leftEditor.scrollIntoView({ line: chunks[0].from, ch: 0 }, 100);
            }
          }
        };
        controls.insertBefore(showDiffsBtn, scrollLockBtn.nextSibling);

        // Add Sort JSON Keys button
        const sortKeysBtn = document.createElement("button");
        sortKeysBtn.className = "toggle-button";
        sortKeysBtn.textContent = "Sort JSON Keys";
        sortKeysBtn.onclick = () => {
          try {
            // Parse and sort left editor content
            let leftObj = JSON.parse(leftEditor.getValue());
            if (Array.isArray(leftObj)) {
              leftObj = sortJSONArray(leftObj);
            } else {
              leftObj = sortJSONKeys(leftObj);
            }
            leftEditor.setValue(JSON.stringify(leftObj, null, 3));

            // Parse and sort right editor content
            let rightObj = JSON.parse(rightEditor.getValue());
            if (Array.isArray(rightObj)) {
              rightObj = sortJSONArray(rightObj);
            } else {
              rightObj = sortJSONKeys(rightObj);
            }
            rightEditor.setValue(JSON.stringify(rightObj, null, 3));

            // Realign chunks after sorting - fix the error
            setTimeout(() => {
              if (mv.alignChunks) {
                mv.alignChunks();
              }
              updateDiffStatus(mv);
            }, 0);
          } catch (e) {
            console.error("Failed to sort JSON:", e);
            alert(
              "Failed to sort JSON. Please ensure both sides contain valid JSON."
            );
          }
        };
        // Insert the sort button after the format button
        const formatBtn = document.getElementById("btn-format");
        controls.insertBefore(sortKeysBtn, formatBtn.nextSibling);

        // Add Share URL button (enhanced with proximity settings)
        const shareBtn = document.createElement("button");
        shareBtn.className = "toggle-button";
        shareBtn.textContent = "ðŸ“‹ Copy Share URL";
        shareBtn.onclick = async () => {
          const leftContent = leftEditor.getValue();
          const rightContent = rightEditor.getValue();
          
          if (!leftContent.trim() && !rightContent.trim()) {
            showNotification("Please add some content to share!", "warning");
            return;
          }
          
          const shareUrl = URLManager.generateShareableURL(leftContent, rightContent, true);
          
          try {
            await navigator.clipboard.writeText(shareUrl);
            
            // Visual feedback
            const originalText = shareBtn.textContent;
            shareBtn.textContent = "âœ… URL Copied!";
            shareBtn.style.backgroundColor = "#28a745";
            
            let message = "Share URL copied to clipboard!";
            if (ProximityManager.settings.enabled) {
              message += " (includes proximity settings)";
            }
            showNotification(message, "success");
            
            setTimeout(() => {
              shareBtn.textContent = originalText;
              shareBtn.style.backgroundColor = "";
            }, 2000);
            
          } catch (err) {
            // Fallback for browsers that don't support clipboard API
            const textArea = document.createElement("textarea");
            textArea.value = shareUrl;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            const originalText = shareBtn.textContent;
            shareBtn.textContent = "âœ… URL Copied!";
            shareBtn.style.backgroundColor = "#28a745";
            
            let message = "Share URL copied to clipboard!";
            if (ProximityManager.settings.enabled) {
              message += " (includes proximity settings)";
            }
            showNotification(message, "success");
            
            setTimeout(() => {
              shareBtn.textContent = originalText;
              shareBtn.style.backgroundColor = "";
            }, 2000);
          }
        };
        controls.insertBefore(shareBtn, sortKeysBtn.nextSibling);

        // Add template selector (enhanced to preserve proximity settings)
        const templateSelect = document.createElement("select");
        templateSelect.className = "toggle-button";
        templateSelect.innerHTML = `
                <option value="">Choose Template...</option>
                <option value="simple">Simple Template</option>
                <option value="complex">Complex Template</option>
                <option value="financial">Financial Data</option>
                <option value="measurements">Measurement Data</option>
            `;
        templateSelect.onchange = () => {
          const templateKey = templateSelect.value;
          if (!templateKey) return;
          
          let template;
          if (templateKey === 'financial') {
            template = {
              left: JSON.stringify({
                "transactions": [
                  {"id": 1, "amount": 19.99, "currency": "USD", "tax": 2.0},
                  {"id": 2, "amount": 100.50, "currency": "USD", "tax": 10.1}
                ],
                "total": 130.59
              }, null, 3),
              right: JSON.stringify({
                "transactions": [
                  {"id": 1, "amount": 19.991, "currency": "USD", "tax": 2.001},
                  {"id": 2, "amount": 101, "currency": "USD", "tax": 10.05}
                ],
                "total": 130.596
              }, null, 3)
            };
          } else if (templateKey === 'measurements') {
            template = {
              left: JSON.stringify({
                "sensors": [
                  {"id": "temp1", "reading": 23.5, "unit": "Â°C", "timestamp": 1640995200},
                  {"id": "press1", "reading": 1013.25, "unit": "hPa", "timestamp": 1640995201}
                ],
                "location": "Lab A"
              }, null, 3),
              right: JSON.stringify({
                "sensors": [
                  {"id": "temp1", "reading": 23.501, "unit": "Â°C", "timestamp": 1640995200},
                  {"id": "press1", "reading": 1014, "unit": "hPa", "timestamp": 1640995202}
                ],
                "location": "Lab A"
              }, null, 3)
            };
          } else {
            template = DefaultTemplates[templateKey];
          }
          
          if (template) {
            leftEditor.setValue(template.left);
            rightEditor.setValue(template.right);
            // Update URL when loading template - include proximity settings
            URLManager.saveToURL(template.left, template.right, true);
            
            // Show helpful notification for financial/measurement templates
            if (templateKey === 'financial' || templateKey === 'measurements') {
              showNotification(`${templateKey} template loaded! Try enabling Smart Numbers to see proximity matching.`, 'info');
            }
          }
          
          // Reset select to placeholder
          templateSelect.value = '';
        };
        controls.appendChild(templateSelect);

        // Add Clear All button (enhanced to preserve proximity settings)
        const clearAllBtn = document.createElement("button");
        clearAllBtn.className = "toggle-button";
        clearAllBtn.textContent = "Clear All";
        clearAllBtn.style.display = "none"; // Initially hidden
        clearAllBtn.onclick = () => {
          leftEditor.setValue("");
          rightEditor.setValue("");
          URLManager.saveToURL("", "", true); // Clear URL parameters but preserve proximity settings
          updateDiffStatus(mv);
        };
        controls.appendChild(clearAllBtn);

        // Add individual clear buttons to each pane
        function addClearButton(editor, side) {
          const wrapper = editor.getWrapperElement();
          const clearBtn = document.createElement("button");
          clearBtn.className = `clear-btn clear-btn-${side}`;
          clearBtn.textContent = "Clear";
          clearBtn.style.display = "none"; // Initially hidden
          clearBtn.onclick = (e) => {
            e.stopPropagation();
            editor.setValue("");
            editor.focus(); // Focus the editor after clearing
            // Update URL when clearing individual editor (preserve proximity settings)
            setTimeout(() => {
              URLManager.saveToURL(leftEditor.getValue(), rightEditor.getValue(), true);
            }, 0);
            updateDiffStatus(mv);
          };

          // Insert the button inside the editor's wrapper
          wrapper.parentNode.style.position = "relative";
          wrapper.parentNode.appendChild(clearBtn);

          return clearBtn;
        }

        // Add paste buttons to each pane
        function addPasteButton(editor, side) {
          const wrapper = editor.getWrapperElement();
          const pasteBtn = document.createElement("button");
          pasteBtn.className = `paste-btn paste-btn-${side}`;
          pasteBtn.textContent = "Paste from Clipboard";
          pasteBtn.style.display = "none"; // Initially hidden
          // Position paste button exactly where clear button is
          pasteBtn.style.top = "5px";
          pasteBtn.style.left = "unset";
          pasteBtn.style.right = "10px";
          pasteBtn.style.transform = "none";
          pasteBtn.style.padding = "3px 8px";
          pasteBtn.style.fontSize = "12px";
          pasteBtn.onclick = async (e) => {
            e.stopPropagation();
            try {
              // Request clipboard permission and get text
              const text = await navigator.clipboard.readText();
              if (text) {
                // Try to format if it's valid JSON
                try {
                  const formatted = JSON.stringify(JSON.parse(text), null, 3);
                  editor.setValue(formatted);
                } catch {
                  // If not valid JSON, just paste as-is
                  editor.setValue(text);
                }
                editor.focus();
                updateDiffStatus(mv);
              }
            } catch (err) {
              console.error("Clipboard permission denied:", err);
              alert("Please allow clipboard access to use the paste feature");
            }
          };

          // Insert the button inside the editor's wrapper
          wrapper.parentNode.appendChild(pasteBtn);

          return pasteBtn;
        }

        // Add clear buttons to both editors
        const leftClearBtn = addClearButton(leftEditor, "left");
        const rightClearBtn = addClearButton(rightEditor, "right");

        // Add paste buttons to both editors
        const leftPasteBtn = addPasteButton(leftEditor, "left");
        const rightPasteBtn = addPasteButton(rightEditor, "right");

        // Function to update button visibility based on content
        function updateClearButtonsVisibility() {
          const leftContent = leftEditor.getValue().trim();
          const rightContent = rightEditor.getValue().trim();

          // Individual clear/paste buttons
          if (leftContent) {
            leftClearBtn.style.display = "block";
            leftPasteBtn.style.display = "none";
          } else {
            leftClearBtn.style.display = "none";
            leftPasteBtn.style.display = "block";
          }
          if (rightContent) {
            rightClearBtn.style.display = "block";
            rightPasteBtn.style.display = "none";
          } else {
            rightClearBtn.style.display = "none";
            rightPasteBtn.style.display = "block";
          }

          // Clear All button - only visible if at least one editor has content
          clearAllBtn.style.display =
            leftContent || rightContent ? "inline-block" : "none";
        }

        // Set initial button visibility based on initial content
        updateClearButtonsVisibility();

        // Auto-save content changes and update URL (enhanced with proximity settings)
        const saveContent = () => {
          const leftContent = leftEditor.getValue();
          const rightContent = rightEditor.getValue();
          
          StorageManager.saveToStorage(leftContent, rightContent, true);
          
          // Update URL parameters for sharing (debounced) - include proximity settings
          clearTimeout(saveContent.urlUpdateTimer);
          saveContent.urlUpdateTimer = setTimeout(() => {
            URLManager.saveToURL(leftContent, rightContent, true);
          }, 1000); // 1 second delay to avoid too frequent URL updates
          
          updateClearButtonsVisibility();
        };

        leftEditor.on("change", (instance, changeObj) => {
          if (changeObj.origin === "paste") {
            try {
              var formatted = JSON.stringify(
                JSON.parse(instance.getValue()),
                null,
                3
              );
              instance.setValue(formatted);
            } catch (e) {
              // Ignore parse errors
            }
          }
          saveContent();
          updateDiffStatus(mv);
        });

        rightEditor.on("change", (instance, changeObj) => {
          if (changeObj.origin === "paste") {
            try {
              var formatted = JSON.stringify(
                JSON.parse(instance.getValue()),
                null,
                3
              );
              instance.setValue(formatted);
            } catch (e) {
              // Ignore parse errors
            }
          }
          saveContent();
          updateDiffStatus(mv);
        });

        // Enhance format button
        document.getElementById("btn-format").onclick = function () {
          const leftContent = leftEditor.getValue().trim();
          const rightContent = rightEditor.getValue().trim();

          // Only proceed if both sides have content
          if (!leftContent || !rightContent) {
            document.getElementById("diff-status").textContent =
              "Please provide content in both panels";
            return;
          }

          try {
            leftEditor.setValue(
              JSON.stringify(JSON.parse(leftEditor.getValue()), null, 3)
            );
            rightEditor.setValue(
              JSON.stringify(JSON.parse(rightEditor.getValue()), null, 3)
            );
            mv.right.operation(() => {
              mv.alignChunks();
            });
          } catch (e) {
            // alert("Invalid JSON detected. Please check your input.");
          }
          updateDiffStatus(mv);
        };

        // Apply proximity-aware diffing
        createProximityAwareDiff(mv);

        updateDiffStatus(mv);
        return mv;
      }

      // Enhanced function to analyze proximity matches
      function analyzeProximityMatches(leftContent, rightContent) {
        if (!ProximityManager.settings.enabled) return { count: 0, details: [] };

        let proximityMatches = 0;
        const matchDetails = [];

        try {
          const leftObj = JSON.parse(leftContent);
          const rightObj = JSON.parse(rightContent);

          function compareObjects(obj1, obj2, path = '') {
            if (typeof obj1 !== typeof obj2) {
              // Check mixed comparison
              if (ProximityManager.settings.mixedComparison) {
                if (ProximityManager.isWithinTolerance(obj1, obj2)) {
                  proximityMatches++;
                  matchDetails.push({
                    path: path || 'root',
                    value1: obj1,
                    value2: obj2,
                    type: 'mixed'
                  });
                }
              }
              return;
            }

            if (obj1 === null || obj2 === null) return;

            if (Array.isArray(obj1) && Array.isArray(obj2)) {
              const maxLen = Math.max(obj1.length, obj2.length);
              for (let i = 0; i < maxLen; i++) {
                if (i < obj1.length && i < obj2.length) {
                  compareObjects(obj1[i], obj2[i], `${path}[${i}]`);
                }
              }
            } else if (typeof obj1 === 'object' && typeof obj2 === 'object') {
              const allKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
              for (const key of allKeys) {
                if (key in obj1 && key in obj2) {
                  const newPath = path ? `${path}.${key}` : key;
                  compareObjects(obj1[key], obj2[key], newPath);
                }
              }
            } else {
              // Primitive values
              if (obj1 !== obj2 && ProximityManager.isWithinTolerance(obj1, obj2)) {
                proximityMatches++;
                const num1 = ProximityManager.parseNumber(obj1);
                const num2 = ProximityManager.parseNumber(obj2);
                const isFloat = (num1 !== null && !Number.isInteger(num1)) || 
                               (num2 !== null && !Number.isInteger(num2));
                
                matchDetails.push({
                  path: path || 'root',
                  value1: obj1,
                  value2: obj2,
                  type: isFloat ? 'float' : 'integer'
                });
              }
            }
          }

          compareObjects(leftObj, rightObj);
        } catch (e) {
          // If JSON parsing fails, try simple text comparison
          const lines1 = leftContent.split('\n');
          const lines2 = rightContent.split('\n');
          
          for (let i = 0; i < Math.min(lines1.length, lines2.length); i++) {
            const line1 = lines1[i].trim();
            const line2 = lines2[i].trim();
            
            if (line1 !== line2 && ProximityManager.isWithinTolerance(line1, line2)) {
              proximityMatches++;
              matchDetails.push({
                path: `line ${i + 1}`,
                value1: line1,
                value2: line2,
                type: 'text'
              });
            }
          }
        }

        return { count: proximityMatches, details: matchDetails };
      }

      function updateDiffStatus(mv) {
        const leftContent = mv.editor().getValue().trim();
        const rightContent = mv.rightOriginal().getValue().trim();

        // Only count differences if both sides have content
        if (!leftContent || !rightContent) {
          document.getElementById("diff-status").textContent =
            "Add JSON content to both sides to compare";
          return;
        }

        const diffs = mv.rightChunks().length;
        let statusText = `Found ${diffs} differences`;

        // Add proximity analysis if enabled
        if (ProximityManager.settings.enabled) {
          const proximityAnalysis = analyzeProximityMatches(leftContent, rightContent);
          if (proximityAnalysis.count > 0) {
            statusText += ` â€¢ ${proximityAnalysis.count} numbers within tolerance`;
            
            // Show detailed tooltip on hover
            const statusElement = document.getElementById("diff-status");
            statusElement.title = proximityAnalysis.details.map(detail => 
              `${detail.path}: ${detail.value1} â‰ˆ ${detail.value2} (${detail.type})`
            ).join('\n');
          }
        }

        document.getElementById("diff-status").textContent = statusText;
      }

      // Custom diff function that respects proximity settings
      function createProximityAwareDiff(mv) {
        const originalDiff = mv.diff;
        
        mv.diff = function() {
          if (!ProximityManager.settings.enabled) {
            return originalDiff.apply(this, arguments);
          }
          
          // If proximity is enabled, we need to customize the diff process
          const leftContent = mv.editor().getValue();
          const rightContent = mv.rightOriginal().getValue();
          
          try {
            const leftObj = JSON.parse(leftContent);
            const rightObj = JSON.parse(rightContent);
            
            // Create modified versions where proximity matches are made identical
            const modifiedLeft = createProximityNormalizedVersion(leftObj);
            const modifiedRight = createProximityNormalizedVersion(rightObj);
            
            // Temporarily set the modified content for diff calculation
            const originalLeftValue = mv.editor().getValue();
            const originalRightValue = mv.rightOriginal().getValue();
            
            mv.editor().setValue(JSON.stringify(modifiedLeft, null, 3));
            mv.rightOriginal().setValue(JSON.stringify(modifiedRight, null, 3));
            
            // Calculate diff with modified content
            const result = originalDiff.apply(this, arguments);
            
            // Restore original content
            mv.editor().setValue(originalLeftValue);
            mv.rightOriginal().setValue(originalRightValue);
            
            return result;
          } catch (e) {
            // If JSON parsing fails, fall back to original diff
            return originalDiff.apply(this, arguments);
          }
        };
      }
      
      function createProximityNormalizedVersion(obj, visited = new Set()) {
        if (obj === null || typeof obj !== 'object') {
          return obj;
        }
        
        // Prevent infinite recursion
        if (visited.has(obj)) {
          return obj;
        }
        visited.add(obj);
        
        if (Array.isArray(obj)) {
          return obj.map(item => createProximityNormalizedVersion(item, visited));
        }
        
        const normalized = {};
        for (const [key, value] of Object.entries(obj)) {
          normalized[key] = createProximityNormalizedVersion(value, visited);
        }
        
        return normalized;
      }

      // Initialize when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        // Load proximity settings first
        ProximityManager.loadSettings();
        
        const target = document.getElementById("view");
        const mv = initializeMergeView(target);
        
        // Show notification if content was loaded from URL
        const urlContent = URLManager.loadFromURL();
        if (urlContent && (urlContent.left || urlContent.right)) {
          // Create and show notification
          const notification = document.createElement("div");
          notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-size: 14px;
            max-width: 300px;
            animation: slideIn 0.3s ease;
          `;
          
          let message = "âœ… Shared comparison loaded successfully!";
          if (ProximityManager.settings.enabled) {
            message += " (Smart Numbers enabled)";
          }
          notification.textContent = message;
          
          // Add animation keyframes
          if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
              @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
              }
              @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
              }
            `;
            document.head.appendChild(style);
          }
          
          document.body.appendChild(notification);
          
          // Auto-remove after 4 seconds
          setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, 4000);
        }
      });
    </script>
  </body>
</html>
