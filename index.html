<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="theme-color" content="#08C988" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Online Text Compare" />
    <title>Compare JSON files online</title>
    <meta
      name="Description"
      content="FREE two-way JSON format, diff and merge tool. No Signup required. Nothing to install. All comparisons are 100% private, secure and happens locally right in your web browser"
    />
    <meta
      name="keywords"
      content="Online JSON Compare - Format and find differences between two JSON files"
    />
    <link
      rel="canonical"
      href="https://dipenparmar12.github.io/json_compair/"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0"
    />
    <link rel="shortcut icon" href="./img/onlinetextcompare.png" />
    <link rel="stylesheet" href="./css/ccsiteV6.css" />
    <link rel="stylesheet" type="text/css" href="./css/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="./css/merge.css" />
    <link rel="stylesheet" type="text/css" href="./css/app.css" />
    <script src="./js/codemirror.js"></script>
    <script src="./js/diff_match_patch.js"></script>
    <script src="./js/merge.js"></script>
    <script src="./js/javascript.js"></script>
  </head>

  <body>
    <article id="ArticlePage" class="contentPage cover">
      <div
        class="intro"
        style="
          max-width: 100%;
          margin: 0;
          padding: 10px 0;
          text-align: center;
          background-color: #f8f9fa;
        "
      >
        <div class="controls">
          <button id="btn-format" class="toggle-button">
            Format &amp; Compare JSON
          </button>
          <!-- Additional controls will be added by JavaScript -->
        </div>
      </div>
    </article>
    <div id="container">
      <div id="view"></div>
      <div id="diff-status">Found 0 differences</div>
    </div>

    <script type="text/javascript">
      // Smart Number Proximity Comparison Manager (enhanced with better UX)
      const ProximityManager = {
        settings: {
          enabled: false,
          floatTolerance: 0.001,
          integerTolerance: 1,
          mixedComparison: true,
          visualFeedback: false,  // Changed default to false
          treatAsMatch: true      // New option: treat proximity values as actual matches
        },

        STORAGE_KEY: 'json_compare_proximity_settings',

        saveSettings: function() {
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.settings));
        },

        loadSettings: function() {
          const stored = localStorage.getItem(this.STORAGE_KEY);
          if (stored) {
            try {
              this.settings = { ...this.settings, ...JSON.parse(stored) };
            } catch (e) {
              console.warn('Failed to load proximity settings');
            }
          }
        },

        isWithinTolerance: function(val1, val2) {
          if (!this.settings.enabled) return val1 === val2;

          // Handle exact matches first
          if (val1 === val2) return true;

          // Convert to numbers if possible
          const num1 = this.parseNumber(val1);
          const num2 = this.parseNumber(val2);

          // If both are numbers, compare with tolerance
          if (num1 !== null && num2 !== null) {
            const isFloat1 = !Number.isInteger(num1);
            const isFloat2 = !Number.isInteger(num2);
            
            if (isFloat1 || isFloat2) {
              // At least one is float, use float tolerance
              return Math.abs(num1 - num2) <= this.settings.floatTolerance;
            } else {
              // Both are integers, use integer tolerance
              return Math.abs(num1 - num2) <= this.settings.integerTolerance;
            }
          }

          // Mixed comparison: string vs number
          if (this.settings.mixedComparison && (num1 !== null || num2 !== null)) {
            const n1 = num1 !== null ? num1 : this.parseNumber(String(val1));
            const n2 = num2 !== null ? num2 : this.parseNumber(String(val2));
            
            if (n1 !== null && n2 !== null) {
              const isFloat = !Number.isInteger(n1) || !Number.isInteger(n2);
              const tolerance = isFloat ? this.settings.floatTolerance : this.settings.integerTolerance;
              return Math.abs(n1 - n2) <= tolerance;
            }
          }

          return false;
        },

        parseNumber: function(value) {
          if (typeof value === 'number') return value;
          if (typeof value !== 'string') return null;
          
          const trimmed = value.trim();
          if (trimmed === '') return null;
          
          const num = Number(trimmed);
          return isNaN(num) ? null : num;
        },

        compareValues: function(val1, val2) {
          return this.isWithinTolerance(val1, val2);
        },

        // Enhanced visual feedback system
        highlightProximityMatches: function(leftEditor, rightEditor) {
          // Only highlight if enabled and visualFeedback is on
          // When treatAsMatch is enabled, don't highlight anything
          if (!this.settings.enabled || !this.settings.visualFeedback || this.settings.treatAsMatch) {
            this.clearHighlights(leftEditor, rightEditor);
            return;
          }

          const leftContent = leftEditor.getValue();
          const rightContent = rightEditor.getValue();
          
          this.clearHighlights(leftEditor, rightEditor);
          
          try {
            const leftObj = JSON.parse(leftContent);
            const rightObj = JSON.parse(rightContent);
            
            this.highlightObjectMatches(leftEditor, rightEditor, leftObj, rightObj);
          } catch (e) {
            // If JSON parsing fails, try line-by-line highlighting
            this.highlightLineMatches(leftEditor, rightEditor);
          }
        },

        highlightObjectMatches: function(leftEditor, rightEditor, leftObj, rightObj) {
          const matches = [];
          
          function findMatches(obj1, obj2, path = '', leftPath = '', rightPath = '') {
            if (typeof obj1 !== typeof obj2) {
              // Only highlight if they're different AND not within tolerance
              if (!ProximityManager.settings.mixedComparison || !ProximityManager.isWithinTolerance(obj1, obj2)) {
                matches.push({ leftPath, rightPath, value1: obj1, value2: obj2 });
              }
              return;
            }

            if (obj1 === null || obj2 === null) return;

            if (Array.isArray(obj1) && Array.isArray(obj2)) {
              const maxLen = Math.max(obj1.length, obj2.length);
              for (let i = 0; i < maxLen; i++) {
                if (i < obj1.length && i < obj2.length) {
                  const newPath = `${path}[${i}]`;
                  findMatches(obj1[i], obj2[i], newPath, newPath, newPath);
                }
              }
            } else if (typeof obj1 === 'object' && typeof obj2 === 'object') {
              const allKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
              for (const key of allKeys) {
                if (key in obj1 && key in obj2) {
                  const newPath = path ? `${path}.${key}` : key;
                  findMatches(obj1[key], obj2[key], newPath, newPath, newPath);
                }
              }
            } else {
              // Primitive values - only highlight if they're different AND NOT within tolerance
              if (obj1 !== obj2 && !ProximityManager.isWithinTolerance(obj1, obj2)) {
                matches.push({ leftPath, rightPath, value1: obj1, value2: obj2 });
              }
            }
          }

          findMatches(leftObj, rightObj);
          
          // Apply highlights based on found matches
          this.applyHighlights(leftEditor, rightEditor, matches);
        },

        highlightLineMatches: function(leftEditor, rightEditor) {
          const leftLines = leftEditor.getValue().split('\n');
          const rightLines = rightEditor.getValue().split('\n');
          
          for (let i = 0; i < Math.min(leftLines.length, rightLines.length); i++) {
            const leftLine = leftLines[i];
            const rightLine = rightLines[i];
            
            // Check if lines contain numbers within tolerance
            const leftNumbers = this.extractNumbers(leftLine);
            const rightNumbers = this.extractNumbers(rightLine);
            
            for (const leftNum of leftNumbers) {
              for (const rightNum of rightNumbers) {
                if (leftNum.value !== rightNum.value && this.isWithinTolerance(leftNum.value, rightNum.value)) {
                  // Highlight the numbers in both editors
                  this.highlightRange(leftEditor, i, leftNum.start, leftNum.end, 'proximity-highlight-left');
                  this.highlightRange(rightEditor, i, rightNum.start, rightNum.end, 'proximity-highlight-right');
                }
              }
            }
          }
        },

        extractNumbers: function(text) {
          const numbers = [];
          const regex = /[-+]?(?:\d*\.?\d+(?:[eE][-+]?\d+)?)/g;
          let match;
          
          while ((match = regex.exec(text)) !== null) {
            const value = parseFloat(match[0]);
            if (!isNaN(value)) {
              numbers.push({
                value: value,
                start: match.index,
                end: match.index + match[0].length,
                text: match[0]
              });
            }
          }
          
          return numbers;
        },

        applyHighlights: function(leftEditor, rightEditor, matches) {
          // This is a simplified version - in practice, you'd need to map object paths to line positions
          const leftContent = leftEditor.getValue();
          const rightContent = rightEditor.getValue();
          
          matches.forEach(match => {
            // Find the position of the values in the text
            const leftPos = this.findValuePosition(leftContent, match.value1);
            const rightPos = this.findValuePosition(rightContent, match.value2);
            
            if (leftPos && rightPos) {
              this.highlightRange(leftEditor, leftPos.line, leftPos.start, leftPos.end, 'proximity-highlight-left');
              this.highlightRange(rightEditor, rightPos.line, rightPos.start, rightPos.end, 'proximity-highlight-right');
            }
          });
        },

        findValuePosition: function(content, value) {
          const lines = content.split('\n');
          const valueStr = String(value);
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const index = line.indexOf(valueStr);
            if (index !== -1) {
              return {
                line: i,
                start: index,
                end: index + valueStr.length
              };
            }
          }
          return null;
        },

        highlightRange: function(editor, line, start, end, className) {
          const from = { line: line, ch: start };
          const to = { line: line, ch: end };
          
          editor.markText(from, to, {
            className: className,
            title: 'Number within tolerance',
            attributes: { 'data-proximity-highlight': 'true' }
          });
        },

        clearHighlights: function(leftEditor, rightEditor) {
          // Clear all proximity highlights
          [leftEditor, rightEditor].forEach(editor => {
            const marks = editor.getAllMarks();
            marks.forEach(mark => {
              if (mark.className && mark.className.startsWith('proximity-highlight')) {
                mark.clear();
              }
            });
          });
        }
      };

      // URL Parameter Manager for shareable links (enhanced with proximity settings)
      const URLManager = {
        // Compress data using LZ-String-like compression (simple implementation)
        compress: function(str) {
          try {
            // Use built-in compression if available, otherwise base64 encode
            return btoa(encodeURIComponent(str));
          } catch (e) {
            console.warn('Compression failed, using fallback');
            return encodeURIComponent(str);
          }
        },

        decompress: function(str) {
          try {
            return decodeURIComponent(atob(str));
          } catch (e) {
            console.warn('Decompression failed, using fallback');
            return decodeURIComponent(str);
          }
        },

        saveToURL: function(leftContent, rightContent, includeProximitySettings = true) {
          const params = new URLSearchParams();
          
          if (leftContent.trim()) {
            params.set('left', this.compress(leftContent));
          }
          if (rightContent.trim()) {
            params.set('right', this.compress(rightContent));
          }

          // Include proximity settings in URL
          if (includeProximitySettings) {
            params.set('proximityEnabled', ProximityManager.settings.enabled ? '1' : '0');
            params.set('floatTolerance', ProximityManager.settings.floatTolerance.toString());
            params.set('integerTolerance', ProximityManager.settings.integerTolerance.toString());
            params.set('mixedComparison', ProximityManager.settings.mixedComparison ? '1' : '0');
            params.set('visualFeedback', ProximityManager.settings.visualFeedback ? '1' : '0');
            params.set('treatAsMatch', ProximityManager.settings.treatAsMatch ? '1' : '0');
          }
          
          const newUrl = window.location.origin + window.location.pathname + 
                        (params.toString() ? '?' + params.toString() : '');
          
          // Update browser URL without page reload
          window.history.replaceState({}, '', newUrl);
          
          return newUrl;
        },

        loadFromURL: function() {
          const params = new URLSearchParams(window.location.search);
          const leftParam = params.get('left');
          const rightParam = params.get('right');
          
          // Load proximity settings from URL
          if (params.has('proximityEnabled')) {
            ProximityManager.settings.enabled = params.get('proximityEnabled') === '1';
            ProximityManager.settings.floatTolerance = parseFloat(params.get('floatTolerance')) || 0.001;
            ProximityManager.settings.integerTolerance = parseInt(params.get('integerTolerance')) || 1;
            ProximityManager.settings.mixedComparison = params.get('mixedComparison') !== '0';
            ProximityManager.settings.visualFeedback = params.get('visualFeedback') === '1';
            ProximityManager.settings.treatAsMatch = params.get('treatAsMatch') !== '0';
          }
          
          if (!leftParam && !rightParam) return null;
          
          return {
            left: leftParam ? this.decompress(leftParam) : '',
            right: rightParam ? this.decompress(rightParam) : ''
          };
        },

        generateShareableURL: function(leftContent, rightContent, includeProximitySettings = true) {
          const params = new URLSearchParams();
          
          if (leftContent.trim()) {
            params.set('left', this.compress(leftContent));
          }
          if (rightContent.trim()) {
            params.set('right', this.compress(rightContent));
          }

          // Include proximity settings in shareable URL if enabled
          if (includeProximitySettings && ProximityManager.settings.enabled) {
            params.set('proximityEnabled', '1');
            params.set('floatTolerance', ProximityManager.settings.floatTolerance.toString());
            params.set('integerTolerance', ProximityManager.settings.integerTolerance.toString());
            params.set('mixedComparison', ProximityManager.settings.mixedComparison ? '1' : '0');
            params.set('visualFeedback', ProximityManager.settings.visualFeedback ? '1' : '0');
            params.set('treatAsMatch', ProximityManager.settings.treatAsMatch ? '1' : '0');
          }
          
          return window.location.origin + window.location.pathname + 
                 (params.toString() ? '?' + params.toString() : '');
        }
      };

      // Storage Manager Implementation (enhanced with proximity settings)
      const StorageManager = {
        STORAGE_KEY: "json_compare_data",
        EXPIRY_DAYS: 30,

        saveToStorage: function (leftContent, rightContent, includeProximitySettings = true) {
          const data = {
            left: leftContent,
            right: rightContent,
            timestamp: new Date().getTime(),
          };

          // Include proximity settings if enabled
          if (includeProximitySettings && ProximityManager.settings.enabled) {
            data.proximitySettings = ProximityManager.settings;
          }

          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        },

        loadFromStorage: function () {
          const storedData = localStorage.getItem(this.STORAGE_KEY);
          if (!storedData) return null;

          const data = JSON.parse(storedData);
          const now = new Date().getTime();
          const age = now - data.timestamp;
          const expiryTime = this.EXPIRY_DAYS * 24 * 60 * 60 * 1000;

          if (age > expiryTime) {
            localStorage.removeItem(this.STORAGE_KEY);
            return null;
          }

          // Restore proximity settings if available
          if (data.proximitySettings) {
            ProximityManager.settings = { ...ProximityManager.settings, ...data.proximitySettings };
          }

          return {
            left: data.left,
            right: data.right,
          };
        },
      };

      // Default templates
      const DefaultTemplates = {
        simple: {
          left: JSON.stringify(
            {
              name: "John",
              age: 30,
              city: "New York",
            },
            null,
            3
          ),
          right: JSON.stringify(
            {
              name: "John",
              age: 31,
              city: "Boston",
            },
            null,
            3
          ),
        },
        complex: {
          left: JSON.stringify(
            {
              users: [
                {
                  id: 1,
                  name: "Alice",
                  active: true,
                },
                {
                  id: 2,
                  name: "Bob",
                  active: false,
                },
              ],
              settings: {
                theme: "dark",
                notifications: true,
              },
            },
            null,
            3
          ),
          right: JSON.stringify(
            {
              users: [
                {
                  id: 1,
                  name: "Alice",
                  active: false,
                },
                {
                  id: 3,
                  name: "Charlie",
                  active: true,
                },
              ],
              settings: {
                theme: "light",
                notifications: true,
              },
            },
            null,
            3
          ),
        },
      };

      // Function to sort JSON object keys recursively
      function sortJSONKeys(obj) {
        if (obj === null || typeof obj !== "object") {
          return obj;
        }
        if (Array.isArray(obj)) {
          return sortJSONArray(obj); // Recursively sort arrays
        }
        const sortedObj = {};
        const keys = Object.keys(obj).sort();
        for (const key of keys) {
          sortedObj[key] = sortJSONKeys(obj[key]);
        }
        return sortedObj;
      }

      // Function to sort array items if they are objects or arrays
      function sortJSONArray(arr) {
        if (!Array.isArray(arr)) {
          return arr;
        }
        // If array contains only objects, sort by their stringified value
        if (
          arr.length > 0 &&
          arr.every(
            (item) =>
              typeof item === "object" && item !== null && !Array.isArray(item)
          )
        ) {
          arr = arr.slice().sort((a, b) => {
            // Sort using stable stringified keys
            const aStr = JSON.stringify(sortJSONKeys(a));
            const bStr = JSON.stringify(sortJSONKeys(b));
            if (aStr < bStr) return -1;
            if (aStr > bStr) return 1;
            return 0;
          });
        }
        return arr.map((item) => {
          if (item && typeof item === "object") {
            return sortJSONKeys(item); // Handles both objects and arrays
          }
          return item;
        });
      }

      // Initialize enhanced merge view
      function initializeMergeView(target) {
        // Load content from URL parameters first, then from storage, then use defaults
        const urlContent = URLManager.loadFromURL();
        const savedContent = StorageManager.loadFromStorage();
        const initialContent = urlContent || savedContent || DefaultTemplates.simple;

        // Create merge view with enhanced options
        const mv = CodeMirror.MergeView(target, {
          value: initialContent.left,
          origLeft: null,
          orig: initialContent.right,
          lineNumbers: true,
          mode: "application/json",
          showDifferences: true,
          connect: "align",
          collapseIdentical: false,
          revertButtons: true,
          allowEditingOriginals: true,
          highlightDifferences: true,
          lineWrapping: true,
          styleActiveLine: true,
          chunkClassLocation: ["background", "wrap", "gutter"],
        });

        // Add scroll synchronization with toggle
        let scrollLocked = true;
        const leftEditor = mv.editor();
        const rightEditor = mv.rightOriginal();

        function syncScroll(sourceEditor, targetEditor) {
          if (!scrollLocked) return;
          const info = sourceEditor.getScrollInfo();
          targetEditor.scrollTo(info.left, info.top);
        }

        leftEditor.on("scroll", () => syncScroll(leftEditor, rightEditor));
        rightEditor.on("scroll", () => syncScroll(rightEditor, leftEditor));

        // Add UI controls
        const controls = document.querySelector(".controls");

        // Create Proximity Settings Panel with improved UI
        const proximityPanel = document.createElement("div");
        proximityPanel.className = "proximity-panel";
        proximityPanel.innerHTML = `
          <div class="proximity-header">
            <button id="proximity-toggle" class="toggle-button" title="Enable Smart Number Proximity Comparison">
              🔢 Smart Numbers
            </button>
            <div class="proximity-settings" style="display: none;">
              <div class="proximity-title">
                <h4>Smart Number Proximity Settings</h4>
                <p>Configure how similar numbers should be treated during comparison</p>
              </div>
              
              <div class="proximity-section">
                <div class="proximity-row">
                  <label>
                    <input type="checkbox" id="proximity-enabled">
                    Enable Smart Number Proximity
                  </label>
                </div>
              </div>
              
              <div class="proximity-section">
                <h5>Tolerance Levels</h5>
                <div class="proximity-row">
                  <label>Float Tolerance:</label>
                  <input type="number" id="float-tolerance" step="0.001" min="0" max="1" value="0.001">
                  <span class="tolerance-example">19.99 ≈ 19.991</span>
                </div>
                <div class="proximity-row">
                  <label>Integer Tolerance:</label>
                  <input type="number" id="integer-tolerance" step="1" min="0" max="100" value="1">
                  <span class="tolerance-example">100 ≈ 101</span>
                </div>
              </div>
              
              <div class="proximity-section">
                <h5>Comparison Options</h5>
                <div class="proximity-row">
                  <label>
                    <input type="checkbox" id="mixed-comparison" checked>
                    Mixed string/number comparison
                  </label>
                  <span class="tolerance-example">Allow comparing "19.99" with 20</span>
                </div>
                <div class="proximity-description">Hide differences for values within tolerance</div>
                <div class="proximity-row">
                  <label>
                    <input type="checkbox" id="treat-as-match" checked>
                    Treat proximity values as exact matches
                  </label>
                </div>
              </div>
              
              <div class="proximity-section">
                <h5>Visual Feedback</h5>
                <div class="proximity-row">
                  <label>
                    <input type="checkbox" id="visual-feedback">
                    Highlight proximity matches
                  </label>
                  <span class="tolerance-example">Show colored indicators for matched numbers</span>
                </div>
              </div>
              
              <div class="proximity-actions">
                <button id="reset-proximity" class="reset-btn">Reset to Defaults</button>
              </div>
            </div>
          </div>
        `;
        controls.appendChild(proximityPanel);

        // Proximity panel open/close only
        const proximityToggle = document.getElementById('proximity-toggle');
        const proximitySettings = document.querySelector('.proximity-settings');
        const floatToleranceInput = document.getElementById('float-tolerance');
        const integerToleranceInput = document.getElementById('integer-tolerance');
        const mixedComparisonInput = document.getElementById('mixed-comparison');
        const visualFeedbackInput = document.getElementById('visual-feedback');
        const treatAsMatchInput = document.getElementById('treat-as-match');
        
        // Get the enable/disable toggle from the panel (already in HTML)
        const proximityEnabledInput = proximitySettings.querySelector('#proximity-enabled');
        
        // Set input values from settings
        floatToleranceInput.value = ProximityManager.settings.floatTolerance;
        integerToleranceInput.value = ProximityManager.settings.integerTolerance;
        mixedComparisonInput.checked = ProximityManager.settings.mixedComparison;
        visualFeedbackInput.checked = ProximityManager.settings.visualFeedback;
        treatAsMatchInput.checked = ProximityManager.settings.treatAsMatch;
        proximityEnabledInput.checked = ProximityManager.settings.enabled;
        // Open/close panel only
        proximityToggle.onclick = () => {
          proximitySettings.style.display = proximitySettings.style.display === 'block' ? 'none' : 'block';
        };
        // Enable/disable proximity feature from panel
        proximityEnabledInput.onchange = () => {
          ProximityManager.settings.enabled = proximityEnabledInput.checked;
          ProximityManager.saveSettings();
          updateDiffStatus(mv);
          if (!ProximityManager.settings.enabled) {
            ProximityManager.clearHighlights(leftEditor, rightEditor);
          } else if (ProximityManager.settings.visualFeedback && !ProximityManager.settings.treatAsMatch) {
            ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
          }
        };
        // Sync checkbox state on panel open
        proximityToggle.addEventListener('click', () => {
          proximityEnabledInput.checked = ProximityManager.settings.enabled;
        });

        // Function to apply settings instantly
        function applyProximitySettings() {
          const floatVal = parseFloat(floatToleranceInput.value);
          const intVal = parseInt(integerToleranceInput.value);
          if (isNaN(floatVal) || floatVal < 0) {
            floatToleranceInput.style.borderColor = '#dc3545';
            return;
          } else {
            floatToleranceInput.style.borderColor = '#ccc';
          }
          if (isNaN(intVal) || intVal < 0) {
            integerToleranceInput.style.borderColor = '#dc3545';
            return;
          } else {
            integerToleranceInput.style.borderColor = '#ccc';
          }
          
          ProximityManager.settings.enabled = proximityEnabledInput.checked;
          ProximityManager.settings.floatTolerance = floatVal;
          ProximityManager.settings.integerTolerance = intVal;
          ProximityManager.settings.mixedComparison = mixedComparisonInput.checked;
          ProximityManager.settings.visualFeedback = visualFeedbackInput.checked;
          ProximityManager.settings.treatAsMatch = treatAsMatchInput.checked;
          ProximityManager.saveSettings();
          
          // Save settings to URL as well
          if (mv) {
            URLManager.saveToURL(mv.editor().getValue(), mv.rightOriginal().getValue(), true);
          }
          
          // Refresh the diff to apply treatAsMatch changes
          if (mv) {
            // For treatAsMatch mode, force a complete recalculation
            if (ProximityManager.settings.enabled && ProximityManager.settings.treatAsMatch) {
              // Store current values
              const leftVal = mv.editor().getValue();
              const rightVal = mv.rightOriginal().getValue();
              
              // Clear both sides completely
              mv.editor().setValue('');
              mv.rightOriginal().setValue('');
              
              // Use setTimeout to ensure the clear happens before setting new values
              setTimeout(() => {
                mv.editor().setValue(leftVal);
                mv.rightOriginal().setValue(rightVal);
                
                // Force diff recalculation
                if (mv.diff) {
                  mv.diff();
                }
              }, 10);
            } else {
              // Normal refresh for other modes
              const leftVal = mv.editor().getValue();
              const rightVal = mv.rightOriginal().getValue();
              mv.editor().setValue(leftVal);
              mv.rightOriginal().setValue(rightVal);
            }
          }
          
          updateDiffStatus(mv);
          
          // Apply highlighting based on settings  
          // Only show highlighting when enabled, visual feedback is on, AND treatAsMatch is OFF
          if (ProximityManager.settings.enabled && ProximityManager.settings.visualFeedback && !ProximityManager.settings.treatAsMatch) {
            setTimeout(() => {
              ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
            }, 100);
          } else {
            // Always clear highlights when treatAsMatch is enabled or visual feedback is disabled
            ProximityManager.clearHighlights(leftEditor, rightEditor);
          }
        }

        // Add instant change handlers for all inputs
        proximityEnabledInput.addEventListener('change', applyProximitySettings);
        floatToleranceInput.addEventListener('input', applyProximitySettings);
        integerToleranceInput.addEventListener('input', applyProximitySettings);
        mixedComparisonInput.addEventListener('change', applyProximitySettings);
        visualFeedbackInput.addEventListener('change', applyProximitySettings);
        treatAsMatchInput.addEventListener('change', applyProximitySettings);

        // Reset proximity settings (no notifications)
        document.getElementById('reset-proximity').onclick = () => {
          ProximityManager.settings.enabled = false;
          ProximityManager.settings.floatTolerance = 0.001;
          ProximityManager.settings.integerTolerance = 1;
          ProximityManager.settings.mixedComparison = true;
          ProximityManager.settings.visualFeedback = false;
          ProximityManager.settings.treatAsMatch = true;
          proximityEnabledInput.checked = ProximityManager.settings.enabled;
          floatToleranceInput.value = ProximityManager.settings.floatTolerance;
          integerToleranceInput.value = ProximityManager.settings.integerTolerance;
          mixedComparisonInput.checked = ProximityManager.settings.mixedComparison;
          visualFeedbackInput.checked = ProximityManager.settings.visualFeedback;
          treatAsMatchInput.checked = ProximityManager.settings.treatAsMatch;
          ProximityManager.saveSettings();
          updateDiffStatus(mv);
          ProximityManager.clearHighlights(leftEditor, rightEditor);
        };

        // Notification system for user feedback
        function showNotification(message, type = 'info') {
          // Remove existing notifications
          const existingNotification = document.querySelector('.proximity-notification');
          if (existingNotification) {
            existingNotification.remove();
          }

          const notification = document.createElement('div');
          notification.className = `proximity-notification ${type}`;
          notification.textContent = message;
          
          // Style based on type
          let backgroundColor = '#007cba'; // info
          if (type === 'success') backgroundColor = '#28a745';
          if (type === 'error') backgroundColor = '#dc3545';
          if (type === 'warning') backgroundColor = '#ffc107';
          
          notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: ${backgroundColor};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-size: 14px;
            max-width: 300px;
            animation: slideIn 0.3s ease;
          `;
          
          document.body.appendChild(notification);
          
          // Auto-remove after 3 seconds
          setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, 3000);
        }

        // Close proximity settings when clicking outside
        document.addEventListener('click', (e) => {
          if (!proximityPanel.contains(e.target)) {
            proximitySettings.style.display = 'none';
          }
        });

        // Prevent closing when clicking inside the settings panel
        proximitySettings.addEventListener('click', (e) => {
          e.stopPropagation();
        });

        // Settings panel stays closed by default - no auto-opening

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          // Ctrl/Cmd + Shift + P: Toggle proximity
          if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'P') {
            e.preventDefault();
            proximityToggle.click();
          }
          
          // Escape: Close proximity settings
          if (e.key === 'Escape') {
            proximitySettings.style.display = 'none';
          }
        });

        // Add scroll lock toggle
        const scrollLockBtn = document.createElement("button");
        scrollLockBtn.className = "toggle-button active";
        scrollLockBtn.textContent = "Scroll Lock";
        scrollLockBtn.onclick = () => {
          scrollLocked = !scrollLocked;
          scrollLockBtn.classList.toggle("active");
        };
        // controls.appendChild(scrollLockBtn);

        // Add Show Only Differences toggle
        const showDiffsBtn = document.createElement("button");
        showDiffsBtn.className = "toggle-button";
        showDiffsBtn.textContent = "Show Only Differences";

        showDiffsBtn.onclick = () => {
          showDiffsBtn.classList.toggle("active");
          const showOnlyDiffs = showDiffsBtn.classList.contains("active");

          const leftPane = leftEditor.getWrapperElement().parentNode;
          const rightPane = rightEditor.getWrapperElement().parentNode;

          leftPane.classList.toggle("show-diffs-only", showOnlyDiffs);
          rightPane.classList.toggle("show-diffs-only", showOnlyDiffs);

          // If showing diffs, ensure chunks are expanded
          if (showOnlyDiffs) {
            // Get all collapsed markers
            const markers = leftEditor.getAllMarks();
            markers.forEach((marker) => {
              if (marker.collapsed) {
                marker.clear();
              }
            });
          }

          // Refresh both editors
          leftEditor.refresh();
          rightEditor.refresh();

          // Adjust viewport to show first diff if exists
          if (showOnlyDiffs) {
            const chunks = mv.rightChunks();
            if (chunks && chunks.length > 0) {
              leftEditor.scrollIntoView({ line: chunks[0].from, ch: 0 }, 100);
            }
          }
        };
        controls.insertBefore(showDiffsBtn, scrollLockBtn.nextSibling);

        // Add Sort JSON Keys button
        const sortKeysBtn = document.createElement("button");
        sortKeysBtn.className = "toggle-button";
        sortKeysBtn.textContent = "Sort JSON Keys";
        sortKeysBtn.onclick = () => {
          try {
            // Parse and sort left editor content
            let leftObj = JSON.parse(leftEditor.getValue());
            if (Array.isArray(leftObj)) {
              leftObj = sortJSONArray(leftObj);
            } else {
              leftObj = sortJSONKeys(leftObj);
            }
            leftEditor.setValue(JSON.stringify(leftObj, null, 3));

            // Parse and sort right editor content
            let rightObj = JSON.parse(rightEditor.getValue());
            if (Array.isArray(rightObj)) {
              rightObj = sortJSONArray(rightObj);
            } else {
              rightObj = sortJSONKeys(rightObj);
            }
            rightEditor.setValue(JSON.stringify(rightObj, null, 3));

            // Realign chunks after sorting - fix the error
            setTimeout(() => {
              if (mv.alignChunks) {
                mv.alignChunks();
              }
              updateDiffStatus(mv);
            }, 0);
          } catch (e) {
            console.error("Failed to sort JSON:", e);
            alert(
              "Failed to sort JSON. Please ensure both sides contain valid JSON."
            );
          }
        };
        // Insert the sort button after the format button
        const formatBtn = document.getElementById("btn-format");
        controls.insertBefore(sortKeysBtn, formatBtn.nextSibling);

        // Add Share URL button (enhanced with proximity settings)
        const shareBtn = document.createElement("button");
        shareBtn.className = "toggle-button";
        shareBtn.textContent = "📋 Copy Share URL";
        shareBtn.onclick = async () => {
          const leftContent = leftEditor.getValue();
          const rightContent = rightEditor.getValue();
          
          if (!leftContent.trim() && !rightContent.trim()) {
            alert("Please add some content to share!");
            return;
          }
          
          const shareUrl = URLManager.generateShareableURL(leftContent, rightContent, true);
          
          try {
            await navigator.clipboard.writeText(shareUrl);
            
            // Visual feedback
            const originalText = shareBtn.textContent;
            shareBtn.textContent = "✅ URL Copied!";
            shareBtn.style.backgroundColor = "#28a745";
            
            setTimeout(() => {
              shareBtn.textContent = originalText;
              shareBtn.style.backgroundColor = "";
            }, 2000);
            
          } catch (err) {
            // Fallback for browsers that don't support clipboard API
            const textArea = document.createElement("textarea");
            textArea.value = shareUrl;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            const originalText = shareBtn.textContent;
            shareBtn.textContent = "✅ URL Copied!";
            shareBtn.style.backgroundColor = "#28a745";
            
            setTimeout(() => {
              shareBtn.textContent = originalText;
              shareBtn.style.backgroundColor = "";
            }, 2000);
          }
        };
        controls.insertBefore(shareBtn, sortKeysBtn.nextSibling);

        // Add template selector (enhanced to preserve proximity settings)
        const templateSelect = document.createElement("select");
        templateSelect.className = "toggle-button";
        templateSelect.innerHTML = `
                <option value="">Choose Template...</option>
                <option value="simple">Simple Template</option>
                <option value="complex">Complex Template</option>
                <option value="financial">Financial Data</option>
                <option value="measurements">Measurement Data</option>
            `;
        templateSelect.onchange = () => {
          const templateKey = templateSelect.value;
          if (!templateKey) return;
          
          let template;
          if (templateKey === 'financial') {
            template = {
              left: JSON.stringify({
                "transactions": [
                  {"id": 1, "amount": 19.99, "currency": "USD", "tax": 2.0},
                  {"id": 2, "amount": 100.50, "currency": "USD", "tax": 10.1}
                ],
                "total": 130.59
              }, null, 3),
              right: JSON.stringify({
                "transactions": [
                  {"id": 1, "amount": 19.991, "currency": "USD", "tax": 2.001},
                  {"id": 2, "amount": 101, "currency": "USD", "tax": 10.05}
                ],
                "total": 130.596
              }, null, 3)
            };
          } else if (templateKey === 'measurements') {
            template = {
              left: JSON.stringify({
                "sensors": [
                  {"id": "temp1", "reading": 23.5, "unit": "°C", "timestamp": 1640995200},
                  {"id": "press1", "reading": 1013.25, "unit": "hPa", "timestamp": 1640995201}
                ],
                "location": "Lab A"
              }, null, 3),
              right: JSON.stringify({
                "sensors": [
                  {"id": "temp1", "reading": 23.501, "unit": "°C", "timestamp": 1640995200},
                  {"id": "press1", "reading": 1014, "unit": "hPa", "timestamp": 1640995202}
                ],
                "location": "Lab A"
              }, null, 3)
            };
          } else {
            template = DefaultTemplates[templateKey];
          }
          
          if (template) {
            leftEditor.setValue(template.left);
            rightEditor.setValue(template.right);
            // Update URL when loading template - include proximity settings
            URLManager.saveToURL(template.left, template.right, true);
            
            // Apply proximity highlighting after loading template
            setTimeout(() => {
              ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
            }, 100);
          }
          
          // Reset select to placeholder
          templateSelect.value = '';
        };
        controls.appendChild(templateSelect);

        // Add Clear All button (enhanced to preserve proximity settings)
        const clearAllBtn = document.createElement("button");
        clearAllBtn.className = "toggle-button";
        clearAllBtn.textContent = "Clear All";
        clearAllBtn.style.display = "none"; // Initially hidden
        clearAllBtn.onclick = () => {
          leftEditor.setValue("");
          rightEditor.setValue("");
          URLManager.saveToURL("", "", true); // Clear URL parameters but preserve proximity settings
          updateDiffStatus(mv);
        };
        controls.appendChild(clearAllBtn);

        // Add individual clear buttons to each pane
        function addClearButton(editor, side) {
          const wrapper = editor.getWrapperElement();
          const clearBtn = document.createElement("button");
          clearBtn.className = `clear-btn clear-btn-${side}`;
          clearBtn.textContent = "Clear";
          clearBtn.style.display = "none"; // Initially hidden
          clearBtn.onclick = (e) => {
            e.stopPropagation();
            editor.setValue("");
            editor.focus(); // Focus the editor after clearing
            // Update URL when clearing individual editor (preserve proximity settings)
            setTimeout(() => {
              URLManager.saveToURL(leftEditor.getValue(), rightEditor.getValue(), true);
            }, 0);
            updateDiffStatus(mv);
          };

          // Insert the button inside the editor's wrapper
          wrapper.parentNode.style.position = "relative";
          wrapper.parentNode.appendChild(clearBtn);

          return clearBtn;
        }

        // Add paste buttons to each pane
        function addPasteButton(editor, side) {
          const wrapper = editor.getWrapperElement();
          const pasteBtn = document.createElement("button");
          pasteBtn.className = `paste-btn paste-btn-${side}`;
          pasteBtn.textContent = "Paste from Clipboard";
          pasteBtn.style.display = "none"; // Initially hidden
          // Position paste button exactly where clear button is
          pasteBtn.style.top = "5px";
          pasteBtn.style.left = "unset";
          pasteBtn.style.right = "10px";
          pasteBtn.style.transform = "none";
          pasteBtn.style.padding = "3px 8px";
          pasteBtn.style.fontSize = "12px";
          pasteBtn.onclick = async (e) => {
            e.stopPropagation();
            try {
              // Request clipboard permission and get text
              const text = await navigator.clipboard.readText();
              if (text) {
                // Try to format if it's valid JSON
                try {
                  const formatted = JSON.stringify(JSON.parse(text), null, 3);
                  editor.setValue(formatted);
                } catch {
                  // If not valid JSON, just paste as-is
                  editor.setValue(text);
                }
                editor.focus();
                updateDiffStatus(mv);
              }
            } catch (err) {
              console.error("Clipboard permission denied:", err);
              alert("Please allow clipboard access to use the paste feature");
            }
          };

          // Insert the button inside the editor's wrapper
          wrapper.parentNode.appendChild(pasteBtn);

          return pasteBtn;
        }

        // Add clear buttons to both editors
        const leftClearBtn = addClearButton(leftEditor, "left");
        const rightClearBtn = addClearButton(rightEditor, "right");

        // Add paste buttons to both editors
        const leftPasteBtn = addPasteButton(leftEditor, "left");
        const rightPasteBtn = addPasteButton(rightEditor, "right");

        // Function to update button visibility based on content
        function updateClearButtonsVisibility() {
          const leftContent = leftEditor.getValue().trim();
          const rightContent = rightEditor.getValue().trim();

          // Individual clear/paste buttons
          if (leftContent) {
            leftClearBtn.style.display = "block";
            leftPasteBtn.style.display = "none";
          } else {
            leftClearBtn.style.display = "none";
            leftPasteBtn.style.display = "block";
          }
          if (rightContent) {
            rightClearBtn.style.display = "block";
            rightPasteBtn.style.display = "none";
          } else {
            rightClearBtn.style.display = "none";
            rightPasteBtn.style.display = "block";
          }

          // Clear All button - only visible if at least one editor has content
          clearAllBtn.style.display =
            leftContent || rightContent ? "inline-block" : "none";
        }

        // Set initial button visibility based on initial content
        updateClearButtonsVisibility();

        // Auto-save content changes and update URL (enhanced with proximity settings)
        const saveContent = () => {
          const leftContent = leftEditor.getValue();
          const rightContent = rightEditor.getValue();
          
          StorageManager.saveToStorage(leftContent, rightContent, true);
          
          // Update URL parameters for sharing (debounced) - include proximity settings
          clearTimeout(saveContent.urlUpdateTimer);
          saveContent.urlUpdateTimer = setTimeout(() => {
            URLManager.saveToURL(leftContent, rightContent, true);
          }, 1000); // 1 second delay to avoid too frequent URL updates
          
          updateClearButtonsVisibility();
        };

        leftEditor.on("change", (instance, changeObj) => {
          if (changeObj.origin === "paste") {
            try {
              var formatted = JSON.stringify(
                JSON.parse(instance.getValue()),
                null,
                3
              );
              instance.setValue(formatted);
            } catch (e) {
              // Ignore parse errors
            }
          }
          saveContent();
          updateDiffStatus(mv);
          
          // Apply proximity highlighting after content change
          setTimeout(() => {
            ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
          }, 100);
        });

        rightEditor.on("change", (instance, changeObj) => {
          if (changeObj.origin === "paste") {
            try {
              var formatted = JSON.stringify(
                JSON.parse(instance.getValue()),
                null,
                3
              );
              instance.setValue(formatted);
            } catch (e) {
              // Ignore parse errors
            }
          }
          saveContent();
          updateDiffStatus(mv);
          
          // Apply proximity highlighting after content change
          setTimeout(() => {
            ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
          }, 100);
        });

        // Enhance format button
        document.getElementById("btn-format").onclick = function () {
          const leftContent = leftEditor.getValue().trim();
          const rightContent = rightEditor.getValue().trim();

          // Only proceed if both sides have content
          if (!leftContent || !rightContent) {
            document.getElementById("diff-status").textContent =
              "Please provide content in both panels";
            return;
          }

          try {
            leftEditor.setValue(
              JSON.stringify(JSON.parse(leftEditor.getValue()), null, 3)
            );
            rightEditor.setValue(
              JSON.stringify(JSON.parse(rightEditor.getValue()), null, 3)
            );
            mv.right.operation(() => {
              mv.alignChunks();
            });
            
            // Apply proximity highlighting after formatting
            setTimeout(() => {
              ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
            }, 100);
          } catch (e) {
            // alert("Invalid JSON detected. Please check your input.");
          }
          updateDiffStatus(mv);
        };

        // Apply proximity-aware diffing
        createProximityAwareDiff(mv);

        // Apply initial proximity highlighting if enabled and content is present
        setTimeout(() => {
          const leftContent = leftEditor.getValue().trim();
          const rightContent = rightEditor.getValue().trim();
          if (leftContent && rightContent) {
            ProximityManager.highlightProximityMatches(leftEditor, rightEditor);
          }
        }, 100);

        updateDiffStatus(mv);
        return mv;
      }

      // Enhanced function to analyze proximity matches
      function analyzeProximityMatches(leftContent, rightContent) {
        if (!ProximityManager.settings.enabled) return { count: 0, details: [] };

        let proximityMatches = 0;
        const matchDetails = [];

        try {
          const leftObj = JSON.parse(leftContent);
          const rightObj = JSON.parse(rightContent);

          function compareObjects(obj1, obj2, path = '') {
            if (typeof obj1 !== typeof obj2) {
              // Check mixed comparison
              if (ProximityManager.settings.mixedComparison) {
                if (ProximityManager.isWithinTolerance(obj1, obj2)) {
                  proximityMatches++;
                  matchDetails.push({
                    path: path || 'root',
                    value1: obj1,
                    value2: obj2,
                    type: 'mixed'
                  });
                }
              }
              return;
            }

            if (obj1 === null || obj2 === null) return;

            if (Array.isArray(obj1) && Array.isArray(obj2)) {
              const maxLen = Math.max(obj1.length, obj2.length);
              for (let i = 0; i < maxLen; i++) {
                if (i < obj1.length && i < obj2.length) {
                  compareObjects(obj1[i], obj2[i], `${path}[${i}]`);
                }
              }
            } else if (typeof obj1 === 'object' && typeof obj2 === 'object') {
              const allKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
              for (const key of allKeys) {
                if (key in obj1 && key in obj2) {
                  const newPath = path ? `${path}.${key}` : key;
                  compareObjects(obj1[key], obj2[key], newPath);
                }
              }
            } else {
              // Primitive values
              if (obj1 !== obj2 && ProximityManager.isWithinTolerance(obj1, obj2)) {
                proximityMatches++;
                const num1 = ProximityManager.parseNumber(obj1);
                const num2 = ProximityManager.parseNumber(obj2);
                const isFloat = (num1 !== null && !Number.isInteger(num1)) || 
                               (num2 !== null && !Number.isInteger(num2));
                
                matchDetails.push({
                  path: path || 'root',
                  value1: obj1,
                  value2: obj2,
                  type: isFloat ? 'float' : 'integer'
                });
              }
            }
          }

          compareObjects(leftObj, rightObj);
        } catch (e) {
          // If JSON parsing fails, try simple text comparison
          const lines1 = leftContent.split('\n');
          const lines2 = rightContent.split('\n');
          
          for (let i = 0; i < Math.min(lines1.length, lines2.length); i++) {
            const line1 = lines1[i].trim();
            const line2 = lines2[i].trim();
            
            if (line1 !== line2 && ProximityManager.isWithinTolerance(line1, line2)) {
              proximityMatches++;
              matchDetails.push({
                path: `line ${i + 1}`,
                value1: line1,
                value2: line2,
                type: 'text'
              });
            }
          }
        }

        return { count: proximityMatches, details: matchDetails };
      }

      function updateDiffStatus(mv) {
        const leftContent = mv.editor().getValue().trim();
        const rightContent = mv.rightOriginal().getValue().trim();

        // Only count differences if both sides have content
        if (!leftContent || !rightContent) {
          document.getElementById("diff-status").textContent =
            "Add JSON content to both sides to compare";
          return;
        }

        const diffs = mv.rightChunks().length;
        let statusText = `Found ${diffs} differences`;

        // Add proximity analysis if enabled
        if (ProximityManager.settings.enabled) {
          const proximityAnalysis = analyzeProximityMatches(leftContent, rightContent);
          if (proximityAnalysis.count > 0) {
            statusText += ` • ${proximityAnalysis.count} numbers within tolerance`;
            
            // Show detailed tooltip on hover
            const statusElement = document.getElementById("diff-status");
            statusElement.title = proximityAnalysis.details.map(detail => 
              `${detail.path}: ${detail.value1} ≈ ${detail.value2} (${detail.type})`
            ).join('\n');
          }
        }

        document.getElementById("diff-status").textContent = statusText;
      }

      // Custom diff function that respects proximity settings
      function createProximityAwareDiff(mv) {
        const originalDiff = mv.diff;
        
        // Override the diff method
        mv.diff = function() {
          // Apply proximity-aware diff when proximity is enabled
          if (!ProximityManager.settings.enabled) {
            return originalDiff.apply(this, arguments);
          }
          
          const leftContent = mv.editor().getValue();
          const rightContent = mv.rightOriginal().getValue();
          
          try {
            const leftObj = JSON.parse(leftContent);
            const rightObj = JSON.parse(rightContent);
            
            // Recursively replace proximity-equal values with a canonical value
            function normalize(obj1, obj2) {
              if (typeof obj1 !== typeof obj2) {
                // Handle mixed type comparison
                if (ProximityManager.settings.mixedComparison && ProximityManager.isWithinTolerance(obj1, obj2)) {
                  return [obj1, obj1]; // Use left value for both
                }
                return [obj1, obj2];
              }
              if (obj1 === null || obj2 === null) return [obj1, obj2];
              if (Array.isArray(obj1) && Array.isArray(obj2)) {
                return [
                  obj1.map((v, i) => normalize(v, obj2[i] !== undefined ? obj2[i] : v)[0]),
                  obj2.map((v, i) => normalize(obj1[i] !== undefined ? obj1[i] : v, v)[1])
                ];
              }
              if (typeof obj1 === 'object' && typeof obj2 === 'object') {
                const keys = Array.from(new Set([...Object.keys(obj1), ...Object.keys(obj2)]));
                const n1 = {};
                const n2 = {};
                for (const k of keys) {
                  const [v1, v2] = normalize(obj1[k], obj2[k]);
                  n1[k] = v1;
                  n2[k] = v2;
                }
                return [n1, n2];
              }
              // Primitive: if proximity match, use left value for both
              if (ProximityManager.isWithinTolerance(obj1, obj2)) {
                return [obj1, obj1];
              }
              return [obj1, obj2];
            }
            
            const [normLeft, normRight] = normalize(leftObj, rightObj);
            
            // Force a complete re-render by recreating the merge view with normalized content
            const normalizedLeftContent = JSON.stringify(normLeft, null, 3);
            const normalizedRightContent = JSON.stringify(normRight, null, 3);
            
            // Temporarily set the normalized content
            const originalLeftValue = mv.editor().getValue();
            const originalRightValue = mv.rightOriginal().getValue();
            
            mv.editor().setValue(normalizedLeftContent);
            mv.rightOriginal().setValue(normalizedRightContent);
            
            // Calculate diff on normalized content
            const result = originalDiff.apply(this, arguments);
            
            // Restore original content
            mv.editor().setValue(originalLeftValue);
            mv.rightOriginal().setValue(originalRightValue);
            
            return result;
          } catch (e) {
            console.warn('Proximity diff normalization failed:', e);
            return originalDiff.apply(this, arguments);
          }
        };
        
        // Also override the forceUpdate method if it exists
        if (mv.forceUpdate) {
          const originalForceUpdate = mv.forceUpdate;
          mv.forceUpdate = function() {
            mv.diff(); // Ensure diff is recalculated
            return originalForceUpdate.apply(this, arguments);
          };
        }
        
        // Override the refresh method if it exists
        if (mv.refresh) {
          const originalRefresh = mv.refresh;
          mv.refresh = function() {
            mv.diff(); // Ensure diff is recalculated
            return originalRefresh.apply(this, arguments);
          };
        }
      }
      
      function createProximityNormalizedVersion(obj, visited = new Set()) {
        if (obj === null || typeof obj !== 'object') {
          return obj;
        }
        
        // Prevent infinite recursion
        if (visited.has(obj)) {
          return obj;
        }
        visited.add(obj);
        
        if (Array.isArray(obj)) {
          return obj.map(item => createProximityNormalizedVersion(item, visited));
        }
        
        const normalized = {};
        for (const [key, value] of Object.entries(obj)) {
          normalized[key] = createProximityNormalizedVersion(value, visited);
        }
        
        return normalized;
      }

      // Initialize when DOM is ready
      document.addEventListener("DOMContentLoaded", () => {
        // Load proximity settings first
        ProximityManager.loadSettings();
        
        const target = document.getElementById("view");
        const mv = initializeMergeView(target);
        
        // Check if content was loaded from URL (no notification)
        const urlContent = URLManager.loadFromURL();
        
        // Add animation keyframes for future use
        if (!document.getElementById('notification-styles')) {
          const style = document.createElement('style');
          style.id = 'notification-styles';
          style.textContent = `
            @keyframes slideIn {
              from { transform: translateX(100%); opacity: 0; }
              to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
              from { transform: translateX(0); opacity: 1; }
              to { transform: translateX(100%); opacity: 0; }
            }
          `;
          document.head.appendChild(style);
        }
      });
    </script>
  </body>
</html>
